# .github/workflows/ci.yml

name: Continuous Integration Pipeline

on:
  push:
    branches:
      - main
      - feature/**
  pull_request:
    branches:
      - main

jobs:
  build_and_deploy: # Renamed job to reflect its full responsibility
    name: ${{ matrix.service }} Build, Test & Deploy
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Allows other services to continue if one fails
      matrix:
        service:
          ["challenge", "community", "gateway", "identity", "learn", "portal"]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Use the latest version

      - name: Set up JDK 11
        uses: actions/setup-java@v4 # Use the latest version
        with:
          distribution: "temurin"
          java-version: "11"

      # 1. FIX: Service-specific caching key
      - name: Cache Maven packages
        uses: actions/cache@v4 # Use the latest version
        with:
          path: ~/.m2/repository
          # HASHES ONLY THE POM.XML FOR THE CURRENT MATRIX SERVICE
          key: ${{ runner.os }}-maven-${{ hashFiles(format('{0}/pom.xml', matrix.service)) }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # 2. IMPROVEMENT: Combine Build and Test into one step
      - name: Build and Test ${{ matrix.service }} service
        run: |
          cd ${{ matrix.service }}
          # 'verify' goal runs tests and ensures the build is complete
          ./mvnw clean verify -B -f pom.xml

      # 3. CONSOLIDATION: Determine if we should push (only on main branch push)
      - name: Set Push Flag
        id: push_flag
        run: echo "SHOULD_PUSH=${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}" >> $GITHUB_OUTPUT

      - name: Log into Docker Hub
        # Only log in if we determined we should push
        if: steps.push_flag.outputs.SHOULD_PUSH == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 4. FIX: Use a single build-push-action step, conditioned by the push flag
      - name: Build and Push Docker Image for ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          # Push is TRUE only when SHOULD_PUSH is 'true'
          push: ${{ steps.push_flag.outputs.SHOULD_PUSH }}
          tags: |
            myregistry/${{ matrix.service }}:latest
            myregistry/${{ matrix.service }}:${{ github.sha }}

  # 5. REMOVAL: Delete the unnecessary 'docker_build' job

  integration_test:
    name: Integration Test
    runs-on: ubuntu-latest
    # Wait for ALL parallel matrix jobs to complete successfully
    needs: [build_and_deploy]
    steps:
      # This is where you would typically use docker-compose to spin up
      # the services using the newly built images (myregistry/service:latest)
      # and run your integration test suite against the live environment.
      - name: placeholder step
        run: echo "All services built, tested, and images pushed. Now running integration tests."
